var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = AxisSets","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [AxisSets]","category":"page"},{"location":"api/#AxisSets.KeyAlignmentError","page":"API","title":"AxisSets.KeyAlignmentError","text":"KeyAlignmentError\n\nIs thrown when the constrained dimensions of components in a KeyedDataset have misaligned key values.\n\nFields\n\nconstraint::Pattern - Constraint pattern describing all dimensions that must align\ngroups - An iterator of paths and keys for each non-matching group\n\n\n\n\n\n","category":"type"},{"location":"api/#AxisSets.KeyedDataset","page":"API","title":"AxisSets.KeyedDataset","text":"KeyedDataset\n\nA KeyedDataset describes an associative collection of component KeyedArrays with constraints on their shared dimensions.\n\nFields\n\nconstraints::OrderedSet{Pattern} - Constraint Patterns on shared dimensions.\ndata::LittleDict{Tuple, KeyedArray} - Flattened key paths as tuples component keyed arrays.\n\n\n\n\n\n","category":"type"},{"location":"api/#AxisSets.KeyedDataset-Tuple","page":"API","title":"AxisSets.KeyedDataset","text":"(ds::KeyedDataset)(key) -> KeyedDataset\n\nA collable syntax for selecting of filtering a subset of a KeyedDataset.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :g1 => [\n                   :a => KeyedArray(zeros(3); time=1:3),\n                   :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n                ],\n                :g2 => [\n                    :a => KeyedArray(ones(3); time=1:3),\n                    :b => KeyedArray(zeros(3, 2); time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> collect(keys(ds(:__, :a).data))\n2-element Vector{Tuple}:\n (:g1, :a)\n (:g2, :a)\n\njulia> collect(keys(ds(:g1, :__).data))\n2-element Vector{Tuple}:\n (:g1, :a)\n (:g1, :b)\n\n\n\n\n\n","category":"method"},{"location":"api/#AxisSets.Pattern","page":"API","title":"AxisSets.Pattern","text":"Pattern\n\nA pattern is just a wrapper around a Tuple which enables searching and filtering for matching components and dimension paths in a KeyedDataset. Special symbols :_ and :__ are used as wildcards, similar to * and ** in glob pattern matching.\n\nExample\n\njulia> using AxisSets: Pattern;\n\njulia> items = [\n           (:train, :input, :load, :time),\n           (:train, :input, :load, :id),\n           (:train, :input, :temperature, :time),\n           (:train, :input, :temperature, :id),\n           (:train, :output, :load, :time),\n           (:train, :output, :load, :id),\n       ];\n\njulia> filter(in(Pattern(:__, :time)), items)\n3-element Vector{NTuple{4, Symbol}}:\n (:train, :input, :load, :time)\n (:train, :input, :temperature, :time)\n (:train, :output, :load, :time)\n\njulia> filter(in(Pattern(:__, :load, :_)), items)\n4-element Vector{NTuple{4, Symbol}}:\n (:train, :input, :load, :time)\n (:train, :input, :load, :id)\n (:train, :output, :load, :time)\n (:train, :output, :load, :id)\n\n\n\n\n\n","category":"type"},{"location":"api/#AxisKeys.axiskeys-Tuple{KeyedDataset}","page":"API","title":"AxisKeys.axiskeys","text":"axiskeys(ds)\naxiskeys(ds, dimname)\naxiskeys(ds, pattern)\naxiskeys(ds, dimpath)\n\nReturns a list of unique axis keys within the KeyedDataset. A Tuple will always be returned unless you explicitly specify the dimpath you want.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> axiskeys(ds)\n(1:4, -1:-1:-3, [:a, :b])\n\njulia> axiskeys(ds, :time)\n(1:4,)\n\njulia> axiskeys(ds, (:val1, :time))\n1:4\n\n\n\n\n\n","category":"method"},{"location":"api/#AxisSets.constraintmap-Tuple{KeyedDataset}","page":"API","title":"AxisSets.constraintmap","text":"constraintmap(ds)\n\nReturns a mapping of constraint patterns to specific dimension paths. The returned dictionary has keys of type Pattern and the values are sets of Tuple.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, constraintmap;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> collect(constraintmap(ds))\n3-element Vector{Pair{AxisSets.Pattern, Set{Tuple}}}:\n Pattern((:__, :time)) => Set([(:val2, :time), (:val1, :time)])\n  Pattern((:__, :loc)) => Set([(:val1, :loc), (:val2, :loc)])\n  Pattern((:__, :obj)) => Set([(:val2, :obj), (:val1, :obj)])\n\n\n\n\n\n","category":"method"},{"location":"api/#AxisSets.dimpaths-Tuple{KeyedDataset, AxisSets.Pattern}","page":"API","title":"AxisSets.dimpaths","text":"dimpaths(ds, [pattern]) -> Vector{<:Tuple}\n\nReturn a list of all dimension paths in the KeyedDataset. Optionally, you can filter the results using a Pattern.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, dimpaths;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> dimpaths(ds)\n6-element Vector{Tuple{Symbol, Symbol}}:\n (:val1, :time)\n (:val1, :loc)\n (:val1, :obj)\n (:val2, :time)\n (:val2, :loc)\n (:val2, :obj)\n\n\n\n\n\n","category":"method"},{"location":"api/#AxisSets.flatten","page":"API","title":"AxisSets.flatten","text":"flatten(collection, [delim])\n\nFlatten a collection of nested associative types into a flat collection of pairs.\n\nExample\n\njulia> using AxisSets: flatten\n\njulia> data = (\n           val1 = (a1 = 1, a2 = 2),\n           val2 = (b1 = 11, b2 = 22),\n           val3 = [111, 222],\n           val4 = 4.3,\n       );\n\njulia> flatten(data, :_)\n(val1_a1 = 1, val1_a2 = 2, val2_b1 = 11, val2_b2 = 22, val3 = [111, 222], val4 = 4.3)\n\nflatten(A, dims, [delim])\n\nFlatten a KeyedArray along the specified consecutive dimensions. The dims argument can either be a Tuple of symbols or a Pair{Tuple, Symbol} if you'd like to specify the desired flattened dimension name.\n\nExample\n\njulia> using AxisKeys, Dates, NamedDims; using AxisSets: flatten\n\njulia> A = KeyedArray(\n           reshape(1:24, (4, 3, 2));\n           time=DateTime(2021, 1, 1, 11):Hour(1):DateTime(2021, 1, 1, 14),\n           obj=[:a, :b, :c],\n           loc=[1, 2],\n       );\n\njulia> dimnames(flatten(A, (:obj, :loc), :_))\n(:time, :obj_loc)\n\n\n\n\n\n","category":"function"},{"location":"api/#AxisSets.rekey-Tuple{Function, KeyedDataset, Vararg{Any, N} where N}","page":"API","title":"AxisSets.rekey","text":"rekey(f, ds, dim)\n\nApply function f to key values of each matching dim in the KeyedDataset. dim can either be a Symbol or a Pattern for the dimension paths.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, rekey;\n\njulia> ds = KeyedDataset(\n           :a => KeyedArray(zeros(3); time=1:3),\n           :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> r = rekey(k -> k .+ 1, ds, :time);\n\njulia> r.time\n3-element ReadOnlyArrays.ReadOnlyArray{Int64, 1, UnitRange{Int64}}:\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"api/#AxisSets.validate-Tuple{KeyedDataset}","page":"API","title":"AxisSets.validate","text":"validate(ds, [constraint])\n\nValidate that all constrained dimension paths within a KeyedDataset have matching key values. Optionally, you can test an explicit constraint Pattern.\n\nReturns\n\ntrue if an error isn't thrown\n\nThrows\n\nArgumentError: If the constraints are not respected\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{KeyedDataset, Symbol}","page":"API","title":"Base.getindex","text":"getindex(ds::KeyedDataset, key)\n\nLookup KeyedDataset component by its Tuple key, or Symbol for keys of depth 1. Shared axis keys for the returned KeyedArray are wrapped in a ReadOnlyArray for safety.\n\nExample\n\n```jldoctest julia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(            :val1 => KeyedArray(zeros(3, 2); time=1:3, obj=[:a, :b]),            :val2 => KeyedArray(ones(3, 2) .+ 1.0; time=1:3, loc=[:x, :y]),        );\n\njulia> ds[:val1] 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:  ↓   time ∈ 3-element ReadOnlyArrays.ReadOnlyArray{Int64,...}   →   obj ∈ 2-element ReadOnlyArrays.ReadOnlyArray{Symbol,...}   And data, 3×2 Array{Float64,2}:        (:a)  (:b)   (1)   0.0   0.0   (2)   0.0   0.0   (3)   0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getproperty-Tuple{KeyedDataset, Symbol}","page":"API","title":"Base.getproperty","text":"getproperty(ds::KeyedDataset, sym::Symbol)\n\nExtract KeyedDataset fields, dimension keys or components in that order. Shared axis keys are wrapped in a ReadOnlyArray for safety.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(zeros(3, 2); time=1:3, obj=[:a, :b]),\n           :val2 => KeyedArray(ones(3, 2) .+ 1.0; time=1:3, loc=[:x, :y]),\n       );\n\njulia> collect(keys(ds.data))\n2-element Vector{Tuple}:\n (:val1,)\n (:val2,)\n\njulia> ds.time\n3-element ReadOnlyArrays.ReadOnlyArray{Int64, 1, UnitRange{Int64}}:\n 1\n 2\n 3\n\njulia> dimnames(ds.val1)\n(:time, :obj)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.map-Tuple{Function, KeyedDataset, Vararg{Any, N} where N}","page":"API","title":"Base.map","text":"map(f, ds, [key]) -> KeyedDataset\n\nApply function f to each component of the KeyedDataset. Returns a new dataset with the same constraints, but new components. The function can be applied to a subselection of components via a Pattern key.\n\nExample\n\njulia> using AxisKeys, Statistics; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :g1 => [\n                   :a => KeyedArray(zeros(3); time=1:3),\n                   :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n                ],\n                :g2 => [\n                    :a => KeyedArray(ones(3); time=1:3),\n                    :b => KeyedArray(zeros(3, 2); time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> r = map(a -> a .+ 100, ds, (:__, :a, :_));  # The extra `:_` is to clarify that we don't care about the dimnames.\n\njulia> [k => mean(v) for (k, v) in r.data]  # KeyedArray printing isn't consistent in jldoctests\n4-element Vector{Pair{Tuple{Symbol, Symbol}, Float64}}:\n (:g1, :a) => 100.0\n (:g1, :b) => 1.0\n (:g2, :a) => 101.0\n (:g2, :b) => 0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.mapslices-Tuple{Function, KeyedDataset, Vararg{Any, N} where N}","page":"API","title":"Base.mapslices","text":"mapslices(f, ds, [key]; dims) -> KeyedDataset\n\nApply the mapslices call to each of the desired components and returns a new KeyedDataset. Selection Patterns may be provided via key, but components are selected by the desired dims by default.\n\nExample\n\njulia> using AxisKeys, Statistics; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(zeros(3, 2); time=1:3, obj=[:a, :b]),\n           :val2 => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> r = mapslices(sum, ds; dims=:time);  # KeyedArray printing isn't consistent in jldoctests\n\njulia> [k => parent(parent(v)) for (k, v) in r.data]\n2-element Vector{Pair{Tuple{Symbol}, Matrix{Float64}}}:\n (:val1,) => [0.0 0.0]\n (:val2,) => [3.0 3.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.merge-Tuple{KeyedDataset, Vararg{KeyedDataset, N} where N}","page":"API","title":"Base.merge","text":"merge(ds::KeyedDataset, others::KeyedDataset...)\n\nCombine the constraints and data from multiple KeyedDatasets.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds1 = KeyedDataset(\n           :a => KeyedArray(zeros(3); time=1:3),\n           :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> ds2 = KeyedDataset(\n           :c => KeyedArray(ones(3); time=1:3),\n           :d => KeyedArray(zeros(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> collect(keys(merge(ds1, ds2).data))\n4-element Vector{Tuple}:\n (:a,)\n (:b,)\n (:c,)\n (:d,)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{KeyedDataset, Any, Symbol}","page":"API","title":"Base.setindex!","text":"setindex!(ds::KeyedDataset{T}, val, key) -> T\n\nStore the new val in the KeyedDataset. If any new dimension names don't any existing constraints then Pattern(:__, <dimname>) is used by default. If the axis values of the new val doesn't meet the existing constraints in the dataset then an error will be throw.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, constraintmap;\n\njulia> ds = KeyedDataset(:a => KeyedArray(zeros(3); time=1:3));\n\njulia> ds[:b] = KeyedArray(ones(3, 2); time=1:3, lag=[-1, -2]);\n\njulia> collect(constraintmap(ds))\n2-element Vector{Pair{AxisSets.Pattern, Set{Tuple}}}:\n Pattern((:__, :time)) => Set([(:b, :time), (:a, :time)])\n  Pattern((:__, :lag)) => Set([(:b, :lag)])\n\njulia> ds[:c] = KeyedArray(ones(3, 2); time=2:4, lag=[-1, -2])\nERROR: KeyAlignmentError: Misaligned dimension keys on constraint Pattern((:__, :time))\n  Tuple[(:b, :time), (:a, :time)] ∈ 3-element UnitRange{Int64}\n  Tuple[(:c, :time)] ∈ 3-element UnitRange{Int64}\n\n\n\n\n\n","category":"method"},{"location":"api/#Impute.apply-Tuple{KeyedDataset, Impute.DeclareMissings}","page":"API","title":"Impute.apply","text":"Impute.apply(ds::KeyedDataset, imp::DeclareMissings)\n\nDeclare missing values across all components in the KeyedDataset.\n\n\n\n\n\n","category":"method"},{"location":"api/#Impute.apply-Tuple{KeyedDataset, Impute.Filter}","page":"API","title":"Impute.apply","text":"Impute.apply(ds, filter; dims)\n\nFilter out missing data along the dims for each component in the KeyedDataset with that dimension.\n\nExample\n\njulia> using AxisKeys, Impute; using AxisSets: KeyedDataset, Pattern, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :train => [\n                   :temp => KeyedArray([1.0 1.1; missing 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.0 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ],\n                :predict => [\n                   :temp => KeyedArray([1.0 missing; 2.0 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.1 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.filter(ds; dims=:time).data]  # KeyedArray printing isn't consistent in jldoctests\n4-element Vector{Pair{Tuple{Symbol, Symbol}, Matrix{Union{Missing, Float64}}}}:\n   (:train, :temp) => [3.0 3.3]\n   (:train, :load) => [9.0 9.9]\n (:predict, :temp) => [3.0 3.3]\n (:predict, :load) => [9.0 9.9]\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.filter(ds; dims=Pattern(:train, :__, :time)).data]\n4-element Vector{Pair{Tuple{Symbol, Symbol}, Matrix{Union{Missing, Float64}}}}:\n   (:train, :temp) => [1.0 1.1; 3.0 3.3]\n   (:train, :load) => [7.0 7.7; 9.0 9.9]\n (:predict, :temp) => [1.0 missing; 3.0 3.3]\n (:predict, :load) => [7.0 7.7; 9.0 9.9]\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.filter(ds; dims=:loc).data]\n4-element Vector{Pair{Tuple{Symbol, Symbol}, Matrix{Union{Missing, Float64}}}}:\n   (:train, :temp) => [1.0 1.1; missing 2.2; 3.0 3.3]\n   (:train, :load) => [7.0; 8.0; 9.0]\n (:predict, :temp) => [1.0 missing; 2.0 2.2; 3.0 3.3]\n (:predict, :load) => [7.0; 8.1; 9.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#Impute.impute-Tuple{KeyedDataset, Impute.Imputor}","page":"API","title":"Impute.impute","text":"Impute.impute(ds, imp; dims)\n\nApply the imputation algorithm imp along the dims for all components of the KeyedDataset with that dimension.\n\nExample\n\njulia> using AxisKeys, Impute; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :train => [\n                   :temp => KeyedArray([1.0 1.1; missing 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.0 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ],\n                :predict => [\n                   :temp => KeyedArray([1.0 missing; 2.0 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.1 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.substitute(ds; dims=:time).data]  # KeyedArray printing isn't consistent in jldoctests\n4-element Vector{Pair{Tuple{Symbol, Symbol}, Matrix{Union{Missing, Float64}}}}:\n   (:train, :temp) => [1.0 1.1; 2.2 2.2; 3.0 3.3]\n   (:train, :load) => [7.0 7.7; 8.0 8.0; 9.0 9.9]\n (:predict, :temp) => [1.0 1.0; 2.0 2.2; 3.0 3.3]\n (:predict, :load) => [7.0 7.7; 8.1 8.1; 9.0 9.9]\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.substitute(ds; dims=:loc).data]\n4-element Vector{Pair{Tuple{Symbol, Symbol}, Matrix{Union{Missing, Float64}}}}:\n   (:train, :temp) => [1.0 1.1; missing 2.2; 3.0 3.3]\n   (:train, :load) => [7.0 7.7; 8.0 8.8; 9.0 9.9]\n (:predict, :temp) => [1.0 missing; 2.0 2.2; 3.0 3.3]\n (:predict, :load) => [7.0 7.7; 8.1 8.8; 9.0 9.9]\n\n\n\n\n\n","category":"method"},{"location":"api/#Impute.validate-Tuple{KeyedDataset, Impute.Validator}","page":"API","title":"Impute.validate","text":"Impute.validate(ds::KeyedDataset, validator::Validator; dims=:)\n\nApply the validator to components in the KeyedDataset with the specified dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#NamedDims.dimnames-Tuple{KeyedDataset}","page":"API","title":"NamedDims.dimnames","text":"dimnames(ds)\n\nReturns a list of the unique dimension names within the KeyedDataset.\n\nExample\n\njulia> using AxisKeys; using NamedDims; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> dimnames(ds)\n3-element Vector{Symbol}:\n :time\n :loc\n :obj\n\n\n\n\n\n","category":"method"},{"location":"#AxisSets","page":"Home","title":"AxisSets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example, we're going to step through a set of common operations we typically perform when converting a collection of individually fetched features into a simple set of training features (X, y) and predict/testing features (X̂, ŷ).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Lets start by loading some packages we'll need.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using AxisKeys, AxisSets, DataFrames, Dates, Impute, Random, Statistics, TimeZones\nusing AxisSets: Pattern, flatten, rekey","category":"page"},{"location":"example/#Data","page":"Example","title":"Data","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"# Only gonna lookback 4 days on the same hour and our training data only covers 1 week\ntrain_input_times = DateTime(2021, 1, 1):Hour(1):DateTime(2021, 1, 7)\ntrain_output_times = train_input_times .+ Day(1)\n\n# Predict times are just the next day\npredict_input_times = DateTime(2021, 1, 7):Hour(1):DateTime(2021, 1, 8)\npredict_output_times = predict_input_times .+ Day(1)\n\n# We're gonna say that price, load and temp nodes are different non-overlapping ids\nprice_ids = [:a, :b, :c, :d]\nload_ids = [:p, :q]\ntemp_ids = [:x, :y, :z]\n\n# Lookback lag for prices, we're only applying the lag to prices just to keep things interesting.\nfeature_lags = Day.(-1:-1:-4)\nrng = MersenneTwister(1234)\n\n# Some\nmisratios = Dict(\n    :a => 0.1,\n    :b => 0.2,\n    :c => 0.3,\n    :d => 0.4,\n    :p => 0.1,\n    :q => 0.2,\n    :x => 0.1,\n    :y => 0.2,\n    :z => 0.3,\n)\n\ntrain_factor = 0.2\npredict_factor = 0.1\n\n# A modified `rand` which has some probability of producing `missing` values based on\n# the id and some preset factor\nfunction misrand(factor, id)::Union{Missing, Float64}\n    ratio = factor * misratios[id]\n    @assert ratio >= 0.0\n    rand(rng) > ratio || return missing\n    return rand(rng)\nend\n\ndata = (\n    train = (\n        input = (\n            prices = DataFrame(\n                (time=t[1], id=t[2], lag=t[3], price=misrand(train_factor, t[2]))\n                for t in Iterators.product(train_input_times, price_ids, feature_lags)\n            ),\n            load = DataFrame(\n                (time=t[1], id=t[2], load=misrand(train_factor, t[2]))\n                for t in Iterators.product(train_input_times, load_ids)\n            ),\n            temp = DataFrame(\n                (time=t[1], id=t[2], temp=misrand(train_factor, t[2]))\n                for t in Iterators.product(train_input_times, temp_ids)\n            ),\n        ),\n        output = (\n            prices = DataFrame(\n                (time=t[1], id=t[2], price=misrand(train_factor, t[2]))\n                for t in Iterators.product(train_output_times, price_ids)\n            ),\n        ),\n    ),\n    predict = (\n        input = (\n            prices = DataFrame(\n                (time=t[1], id=t[2], lag=t[3], price=misrand(predict_factor, t[2]))\n                for t in Iterators.product(predict_input_times, price_ids, feature_lags)\n            ),\n            load = DataFrame(\n                (time=t[1], id=t[2], load=misrand(predict_factor, t[2]))\n                for t in Iterators.product(predict_input_times, load_ids)\n            ),\n            temp = DataFrame(\n                (time=t[1], id=t[2], temp=misrand(predict_factor, t[2]))\n                for t in Iterators.product(predict_input_times, temp_ids)\n            ),\n        ),\n        output = (\n            prices = DataFrame(\n                (time=t[1], id=t[2], price=misrand(predict_factor, t[2]))\n                for t in Iterators.product(predict_output_times, price_ids)\n            ),\n        ),\n    ),\n)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To see how we can use AxisSets.jl to aid with data wrangling problems, we're going to assume our dataset is a nested NamedTuple of DataFrames. We're using DataFrames for simplicity, but we could also construct our Dataset from a LibPQ.Result or anything else that follows the Tables interface. Let's start by taking a look at what our data looks like. To make things easier we're gonna flatten our nested structure and display the column names for each dataframe.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"flattened = AxisSets.flatten(data)\nd = Dict(flattened...)\nDict(k => names(v) for (k, v) in flattened)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Something you may notice about our data is that each component has a :time and :id column which uniquely identify each value. Therefore we can more compactly represent our components as AxisKeys.KeyedArrays.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"components = (\n    k => allowmissing(wrapdims(v, Tables.columnnames(v)[end], Tables.columnnames(v)[1:end-1]...))\n    for (k, v) in flattened\n)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This representation avoids storing duplicate :time and :id column values and allows us to perform normal n-dimensional array operation over the dataset more efficiently.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"If we look a little closer we'll also find that several of these \"key\" columns align across the dataframes, while others do not.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For example, the :time columns across train_input tables align. Similarly the :id columns match for both train_input_prices and train_output_prices.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@assert issetequal(d[(:train, :input, :temp)].time, d[(:train, :input, :load)].time)\n@assert issetequal(d[(:train, :input, :prices)].id, d[(:train, :output, :prices)].id)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"However, not all time or id columns need to align.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@assert !issetequal(d[(:train, :input, :prices)].time, d[(:train, :output, :prices)].time)\n@assert !issetequal(d[(:train, :input, :temp)].id, d[(:train, :input, :load)].id)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It turns out we can summarize these alignment \"constraints\" pretty concisely.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"All time columns must align within each of the 4 train/predict x input/output combinations.\nAll id columns must align for each prices, temp and load.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"With AxisSets.jl we can declaratively state these alignment assumptions using Patterns.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Constraint patterns on :time","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"time_constraints = Pattern[\n    # All train input time keys should match\n    (:train, :input, :_, :time),\n\n    # All train output time keys should match\n    (:train, :output, :_, :time),\n\n    # All predict input time keys should match\n    (:predict, :input, :_, :time),\n\n    # All predict output time keys should match\n    (:predict, :output, :_, :time),\n]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Constraint patterns on :id","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"id_constraints = Pattern[\n    # All ids for each data type should align across\n    (:__, :prices, :id),\n    (:__, :temp, :id),\n    (:__, :load, :id),\n]","category":"page"},{"location":"example/#KeyedDataset","page":"Example","title":"KeyedDataset","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"How can we make the constraint Patterns and component KeyedArrays more useful to us? Well, we can now combine our constraints and component KeyedArrays into a KeyedDataset.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ds = KeyedDataset(components...; constraints=vcat(time_constraints, id_constraints))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The objective of this type is to address two primary issues:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Ensure that our data wrangling operations won't violate our constraints outlined above.\nProvide batched operations to minimize verbose data wrangling operations.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Let's perform some common operations:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We often want to filter out ids being consider if they have too many missing values. Lets try just applying this filtering rule to each component of our dataset","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"unique(\n    axiskeys(Impute.filter(x -> mean(ismissing, x) < 0.1, v; dims=:id), :id)\n    for (k, v) in ds.data\n)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We can see that doing this results in inconsistent :id keys across our components. Now lets try applying a batched version of that filtering rule across the entire dataset.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ds = Impute.filter(x -> mean(ismissing, x) < 0.1, ds; dims=:id)\nunique(axiskeys(ds, :id))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Notice how our returned KeyedDataset respects the :id constraints we provided above. Another kind of filtering we often do is dropping hours with any missing data after this point.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ds = Impute.filter(ds; dims=:time)\nunique(axiskeys(ds, :time))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"You'll notice that we may have up-to 4 unique :time keys among our 8 components. This is because we only expect keys to align across each :train/predict and input/output combinations as described above.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Finally, we should be able to restrict the component KeyedArrays to disallowmissing.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ds = map(disallowmissing, ds)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Another common operation is to mutate the key values in batches. In this case, we'll say that we need to convert the :time keys to ZonedDateTimes.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ds = rekey(k -> ZonedDateTime.(k, tz\"UTC\"), ds, :time)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Okay, so now that all of our data manipulation is complete we want to combine all our components into 4 simple 2-d matrices","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"results = (\n    X = hcat(\n        flatten(ds[(:train, :input, :prices)], (:id, :lag) => :id),\n        ds[(:train, :input, :temp)],\n        ds[(:train, :input, :load)],\n    ),\n    y = ds[(:train, :output, :prices)],\n    X̂ = hcat(\n        flatten(ds[(:predict, :input, :prices)], (:id, :lag) => :id),\n        ds[(:predict, :input, :temp)],\n        ds[(:predict, :input, :load)],\n    ),\n    ŷ = ds[(:predict, :output, :prices)],\n)\nresults.X","category":"page"}]
}
