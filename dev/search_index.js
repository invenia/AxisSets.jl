var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = AxisSets","category":"page"},{"location":"#AxisSets","page":"Home","title":"AxisSets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [AxisSets]","category":"page"},{"location":"#AxisSets.DEFAULT_FLATTEN_DELIM","page":"Home","title":"AxisSets.DEFAULT_FLATTEN_DELIM","text":"DEFAULT_FLATTEN_DELIM\n\n:⁻ (or \\^-)\n\nSeparates the parent symbols of a nested NamedTuple that has been flattened. A less common symbol was used to avoid collisions with :_ in the parent symbols.\n\nExample\n\njulia> using AxisSets: flatten\n\njulia> data = (\n           val1 = (a1 = 1, a2 = 2),\n           val2 = (b1 = 11, b2 = 22),\n           val3 = [111, 222],\n           val4 = 4.3,\n       );\n\njulia> flatten(data)\n(val1⁻a1 = 1, val1⁻a2 = 2, val2⁻b1 = 11, val2⁻b2 = 22, val3 = [111, 222], val4 = 4.3)\n\n\n\n\n\n","category":"constant"},{"location":"#AxisSets.DEFAULT_PROD_DELIM","page":"Home","title":"AxisSets.DEFAULT_PROD_DELIM","text":"DEFAULT_PROD_DELIM\n\n:ᵡ (or \\^x)\n\nSeparates the parent symbols from an n-dimensional array that was flattened / reshaped. A less common symbol was used to avoid collisions with :_ in the parent symbols.\n\nExample\n\njulia> using AxisKeys, Dates; using AxisSets: flatten\n\njulia> A = KeyedArray(\n           reshape(1:24, (4, 3, 2));\n           time=DateTime(2021, 1, 1, 11):Hour(1):DateTime(2021, 1, 1, 14),\n           obj=[:a, :b, :c],\n           loc=[1, 2],\n       );\n\njulia> axiskeys(flatten(A, (:obj, :loc)), :objᵡloc)\n6-element Array{Symbol,1}:\n :aᵡ1\n :bᵡ1\n :cᵡ1\n :aᵡ2\n :bᵡ2\n :cᵡ2\n\n\n\n\n\n","category":"constant"},{"location":"#AxisSets.KeyedDataset","page":"Home","title":"AxisSets.KeyedDataset","text":"KeyedDataset{T}\n\nA KeyedDataset describes an associative collection of component KeyedArrays with constraints on their shared dimensions.\n\nFields\n\nconstraints::OrderedSet{Pattern} - Constraint Patterns on shared dimensions.\ndata::LittleDict{Tuple{Vararg{Symbol}}, T} - Flattened key paths as tuples of symbols to each component array of type T.\n\n\n\n\n\n","category":"type"},{"location":"#AxisSets.KeyedDataset-Tuple","page":"Home","title":"AxisSets.KeyedDataset","text":"(ds::KeyedDataset)(key) -> KeyedDataset\n\nA collable syntax for selecting of filtering a subset of a KeyedDataset.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :g1 => [\n                   :a => KeyedArray(zeros(3); time=1:3),\n                   :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n                ],\n                :g2 => [\n                    :a => KeyedArray(ones(3); time=1:3),\n                    :b => KeyedArray(zeros(3, 2); time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> collect(keys(ds(:__, :a).data))\n2-element Array{Tuple{Vararg{Symbol,N} where N},1}:\n (:g1, :a)\n (:g2, :a)\n\njulia> collect(keys(ds(:g1, :__).data))\n2-element Array{Tuple{Vararg{Symbol,N} where N},1}:\n (:g1, :a)\n (:g1, :b)\n\n\n\n\n\n","category":"method"},{"location":"#AxisSets.Pattern","page":"Home","title":"AxisSets.Pattern","text":"Pattern\n\nA pattern is just a wrapper around a Tuple{Vararg{Symbol}} which enables searching and filtering for matching components and dimension paths in a KeyedDataset. Special symbols :_ and :__ are used as wildcards, similar to * and ** in glob pattern matching.\n\nExample\n\njulia> using AxisSets: Pattern;\n\njulia> items = [\n           (:train, :input, :load, :time),\n           (:train, :input, :load, :id),\n           (:train, :input, :temperature, :time),\n           (:train, :input, :temperature, :id),\n           (:train, :output, :load, :time),\n           (:train, :output, :load, :id),\n       ];\n\njulia> filter(in(Pattern(:__, :time)), items)\n3-element Array{NTuple{4,Symbol},1}:\n (:train, :input, :load, :time)\n (:train, :input, :temperature, :time)\n (:train, :output, :load, :time)\n\njulia> filter(in(Pattern(:__, :load, :_)), items)\n4-element Array{NTuple{4,Symbol},1}:\n (:train, :input, :load, :time)\n (:train, :input, :load, :id)\n (:train, :output, :load, :time)\n (:train, :output, :load, :id)\n\n\n\n\n\n","category":"type"},{"location":"#AxisKeys.axiskeys-Tuple{KeyedDataset}","page":"Home","title":"AxisKeys.axiskeys","text":"axiskeys(ds)\naxiskeys(ds, dimname)\naxiskeys(ds, pattern)\naxiskeys(ds, dimpath)\n\nReturns a list of unique axis keys within the KeyedDataset. A Tuple will always be returned unless you explicitly specify the dimpath you want.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> axiskeys(ds)\n(1:4, -1:-1:-3, [:a, :b])\n\njulia> axiskeys(ds, :time)\n(1:4,)\n\njulia> axiskeys(ds, (:val1, :time))\n1:4\n\n\n\n\n\n","category":"method"},{"location":"#AxisSets.constraintmap-Tuple{KeyedDataset}","page":"Home","title":"AxisSets.constraintmap","text":"constraintmap(ds)\n\nReturns a mapping of constraint patterns to specific dimension paths. The returned dictionary has keys of type Pattern and the values are sets of Tuple{Vararg{Symbol}}.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, constraintmap;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> collect(constraintmap(ds))\n3-element Array{Pair{AxisSets.Pattern,Set{Tuple{Vararg{Symbol,N} where N}}},1}:\n AxisSets.Pattern((:__, :time)) => Set([(:val2, :time), (:val1, :time)])\n  AxisSets.Pattern((:__, :loc)) => Set([(:val1, :loc), (:val2, :loc)])\n  AxisSets.Pattern((:__, :obj)) => Set([(:val2, :obj), (:val1, :obj)])\n\n\n\n\n\n","category":"method"},{"location":"#AxisSets.dimpaths-Tuple{KeyedDataset,AxisSets.Pattern}","page":"Home","title":"AxisSets.dimpaths","text":"dimpaths(ds, [pattern]) -> Vector{<:Tuple{Vararg{Symbol}}}\n\nReturn a list of all dimension paths in the KeyedDataset. Optionally, you can filter the results using a Pattern.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, dimpaths;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> dimpaths(ds)\n6-element Array{Tuple{Symbol,Symbol},1}:\n (:val1, :time)\n (:val1, :loc)\n (:val1, :obj)\n (:val2, :time)\n (:val2, :loc)\n (:val2, :obj)\n\n\n\n\n\n","category":"method"},{"location":"#AxisSets.flatten","page":"Home","title":"AxisSets.flatten","text":"flatten(collection, [delim])\n\nFlatten a collection of nested associative types into a flat collection of pairs. If the input keys are symbols (ie: NamedTuple) then the ⁻  will be used, otherwise Tuple keys will be returned.\n\nExample\n\njulia> using AxisSets: flatten\n\njulia> data = (\n           val1 = (a1 = 1, a2 = 2),\n           val2 = (b1 = 11, b2 = 22),\n           val3 = [111, 222],\n           val4 = 4.3,\n       );\n\njulia> flatten(data)\n(val1⁻a1 = 1, val1⁻a2 = 2, val2⁻b1 = 11, val2⁻b2 = 22, val3 = [111, 222], val4 = 4.3)\n\nflatten(A, dims, [delim])\n\nFlatten a KeyedArray along the specified consecutive dimensions. The dims argument can either be a Tuple of symbols or a Pair{Tuple, Symbol} if you'd like to specify the desired flattened dimension name. If the dims is just a Tuple with no output dimension specified then ᵡ will be used to generate the new dimension name.\n\nExample\n\njulia> using AxisKeys, Dates, NamedDims; using AxisSets: flatten\n\njulia> A = KeyedArray(\n           reshape(1:24, (4, 3, 2));\n           time=DateTime(2021, 1, 1, 11):Hour(1):DateTime(2021, 1, 1, 14),\n           obj=[:a, :b, :c],\n           loc=[1, 2],\n       );\n\njulia> dimnames(flatten(A, (:obj, :loc)))\n(:time, :objᵡloc)\n\n\n\n\n\n","category":"function"},{"location":"#AxisSets.rekey-Tuple{Function,KeyedDataset,Vararg{Any,N} where N}","page":"Home","title":"AxisSets.rekey","text":"rekey(f, ds, dim)\n\nApply function f to key values of each matching dim in the KeyedDataset. dim can either be a Symbol or a Pattern for the dimension paths.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, rekey;\n\njulia> ds = KeyedDataset(\n           :a => KeyedArray(zeros(3); time=1:3),\n           :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> r = rekey(k -> k .+ 1, ds, :time);\n\njulia> r.time\n3-element ReadOnlyArrays.ReadOnlyArray{Int64,1,UnitRange{Int64}}:\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"#AxisSets.validate-Tuple{KeyedDataset}","page":"Home","title":"AxisSets.validate","text":"validate(ds, [constraint])\n\nValidate that all constrained dimension paths within a KeyedDataset have matching key values. Optionally, you can test an explicit constraint Pattern.\n\nReturns\n\ntrue if an error isn't thrown\n\nThrows\n\nArgumentError: If the constraints are not respected\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{KeyedDataset,Symbol}","page":"Home","title":"Base.getindex","text":"getindex(ds::KeyedDataset, key)\n\nLookup KeyedDataset component by its Tuple key, or Symbol for keys of depth 1. Shared axis keys for the returned KeyedArray are wrapped in a ReadOnlyArray for safety.\n\nExample\n\n```jldoctest julia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(            :val1 => KeyedArray(zeros(3, 2); time=1:3, obj=[:a, :b]),            :val2 => KeyedArray(ones(3, 2) .+ 1.0; time=1:3, loc=[:x, :y]),        );\n\njulia> ds[:val1] 2-dimensional KeyedArray(NamedDimsArray(...)) with keys:  ↓   time ∈ 3-element ReadOnlyArrays.ReadOnlyArray{Int64,...}   →   obj ∈ 2-element ReadOnlyArrays.ReadOnlyArray{Symbol,...}   And data, 3×2 Array{Float64,2}:        (:a)  (:b)   (1)   0.0   0.0   (2)   0.0   0.0   (3)   0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.getproperty-Tuple{KeyedDataset,Symbol}","page":"Home","title":"Base.getproperty","text":"getproperty(ds::KeyedDataset, sym::Symbol)\n\nExtract KeyedDataset fields, dimension keys or components in that order. Shared axis keys are wrapped in a ReadOnlyArray for safety.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(zeros(3, 2); time=1:3, obj=[:a, :b]),\n           :val2 => KeyedArray(ones(3, 2) .+ 1.0; time=1:3, loc=[:x, :y]),\n       );\n\njulia> collect(keys(ds.data))\n2-element Array{Tuple{Vararg{Symbol,N} where N},1}:\n (:val1,)\n (:val2,)\n\njulia> ds.time\n3-element ReadOnlyArrays.ReadOnlyArray{Int64,1,UnitRange{Int64}}:\n 1\n 2\n 3\n\njulia> dimnames(ds.val1)\n(:time, :obj)\n\n\n\n\n\n","category":"method"},{"location":"#Base.map-Tuple{Function,KeyedDataset,Vararg{Any,N} where N}","page":"Home","title":"Base.map","text":"map(f, ds, [key]) -> KeyedDataset\n\nApply function f to each component of the KeyedDataset. Returns a new dataset with the same constraints, but new components. The function can be applied to a subselection of components via a Pattern key.\n\nExample\n\njulia> using AxisKeys, Statistics; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :g1 => [\n                   :a => KeyedArray(zeros(3); time=1:3),\n                   :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n                ],\n                :g2 => [\n                    :a => KeyedArray(ones(3); time=1:3),\n                    :b => KeyedArray(zeros(3, 2); time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> r = map(a -> a .+ 100, ds, (:__, :a, :_));  # The extra `:_` is to clarify that we don't care about the dimnames.\n\njulia> [k => mean(v) for (k, v) in r.data]  # KeyedArray printing isn't consistent in jldoctests\n4-element Array{Pair{Tuple{Symbol,Symbol},Float64},1}:\n (:g1, :a) => 100.0\n (:g1, :b) => 1.0\n (:g2, :a) => 101.0\n (:g2, :b) => 0.0\n\n\n\n\n\n","category":"method"},{"location":"#Base.mapslices-Tuple{Function,KeyedDataset,Vararg{Any,N} where N}","page":"Home","title":"Base.mapslices","text":"mapslices(f, ds, [key]; dims) -> KeyedDataset\n\nApply the mapslices call to each of the desired components and returns a new KeyedDataset. Selection Patterns may be provided via key, but components are selected by the desired dims by default.\n\nExample\n\njulia> using AxisKeys, Statistics; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(zeros(3, 2); time=1:3, obj=[:a, :b]),\n           :val2 => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> r = mapslices(sum, ds; dims=:time);  # KeyedArray printing isn't consistent in jldoctests\n\njulia> [k => parent(parent(v)) for (k, v) in r.data]\n2-element Array{Pair{Tuple{Symbol},Array{Float64,2}},1}:\n (:val1,) => [0.0 0.0]\n (:val2,) => [3.0 3.0]\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{KeyedDataset,Vararg{KeyedDataset,N} where N}","page":"Home","title":"Base.merge","text":"merge(ds::KeyedDataset, others::KeyedDataset...)\n\nCombine the constraints and data from multiple KeyedDatasets.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset;\n\njulia> ds1 = KeyedDataset(\n           :a => KeyedArray(zeros(3); time=1:3),\n           :b => KeyedArray(ones(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> ds2 = KeyedDataset(\n           :c => KeyedArray(ones(3); time=1:3),\n           :d => KeyedArray(zeros(3, 2); time=1:3, loc=[:x, :y]),\n       );\n\njulia> collect(keys(merge(ds1, ds2).data))\n4-element Array{Tuple{Vararg{Symbol,N} where N},1}:\n (:a,)\n (:b,)\n (:c,)\n (:d,)\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex!-Tuple{KeyedDataset,Any,Symbol}","page":"Home","title":"Base.setindex!","text":"setindex!(ds::KeyedDataset{T}, val, key) -> T\n\nStore the new val in the KeyedDataset. If any new dimension names don't any existing constraints then Pattern(:__, <dimname>) is used by default. If the axis values of the new val doesn't meet the existing constraints in the dataset then an error will be throw.\n\nExample\n\njulia> using AxisKeys; using AxisSets: KeyedDataset, constraintmap;\n\njulia> ds = KeyedDataset(:a => KeyedArray(zeros(3); time=1:3));\n\njulia> ds[:b] = KeyedArray(ones(3, 2); time=1:3, lag=[-1, -2]);\n\njulia> collect(constraintmap(ds))\n2-element Array{Pair{AxisSets.Pattern,Set{Tuple{Vararg{Symbol,N} where N}}},1}:\n AxisSets.Pattern((:__, :time)) => Set([(:b, :time), (:a, :time)])\n  AxisSets.Pattern((:__, :lag)) => Set([(:b, :lag)])\n\njulia> ds[:c] = KeyedArray(ones(3, 2); time=2:4, lag=[-1, -2])\nERROR: ArgumentError: Shared dimensions don't have matching keys\n\n\n\n\n\n","category":"method"},{"location":"#Impute.apply-Tuple{KeyedDataset,Impute.DeclareMissings}","page":"Home","title":"Impute.apply","text":"Impute.apply(ds::KeyedDataset, imp::DeclareMissings)\n\nDeclare missing values across all components in the KeyedDataset.\n\n\n\n\n\n","category":"method"},{"location":"#Impute.apply-Tuple{KeyedDataset,Impute.Filter}","page":"Home","title":"Impute.apply","text":"Impute.apply(ds, filter; dims)\n\nFilter out missing data along the dims for each component in the KeyedDataset with that dimension.\n\nExample\n\njulia> using AxisKeys, Impute; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :train => [\n                   :temp => KeyedArray([1.0 1.1; missing 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.0 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ],\n                :predict => [\n                   :temp => KeyedArray([1.0 missing; 2.0 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.1 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.filter(ds; dims=:time).data]  # KeyedArray printing isn't consistent in jldoctests\n4-element Array{Pair{Tuple{Symbol,Symbol},Array{Union{Missing, Float64},2}},1}:\n   (:train, :temp) => [3.0 3.3]\n   (:train, :load) => [9.0 9.9]\n (:predict, :temp) => [3.0 3.3]\n (:predict, :load) => [9.0 9.9]\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.filter(ds; dims=:loc).data]\n4-element Array{Pair{Tuple{Symbol,Symbol},Array{Union{Missing, Float64},2}},1}:\n   (:train, :temp) => [1.0 1.1; missing 2.2; 3.0 3.3]\n   (:train, :load) => [7.0; 8.0; 9.0]\n (:predict, :temp) => [1.0 missing; 2.0 2.2; 3.0 3.3]\n (:predict, :load) => [7.0; 8.1; 9.0]\n\n\n\n\n\n","category":"method"},{"location":"#Impute.impute-Tuple{KeyedDataset,Impute.Imputor}","page":"Home","title":"Impute.impute","text":"Impute.impute(ds, imp; dims)\n\nApply the imputation algorithm imp along the dims for all components of the KeyedDataset with that dimension.\n\nExample\n\njulia> using AxisKeys, Impute; using AxisSets: KeyedDataset, flatten;\n\njulia> ds = KeyedDataset(\n           flatten([\n               :train => [\n                   :temp => KeyedArray([1.0 1.1; missing 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.0 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ],\n                :predict => [\n                   :temp => KeyedArray([1.0 missing; 2.0 2.2; 3.0 3.3]; time=1:3, id=[:a, :b]),\n                   :load => KeyedArray([7.0 7.7; 8.1 missing; 9.0 9.9]; time=1:3, loc=[:x, :y]),\n                ]\n            ])...\n       );\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.substitute(ds; dims=:time).data]  # KeyedArray printing isn't consistent in jldoctests\n4-element Array{Pair{Tuple{Symbol,Symbol},Array{Union{Missing, Float64},2}},1}:\n   (:train, :temp) => [1.0 1.1; 2.2 2.2; 3.0 3.3]\n   (:train, :load) => [7.0 7.7; 8.0 8.0; 9.0 9.9]\n (:predict, :temp) => [1.0 1.0; 2.0 2.2; 3.0 3.3]\n (:predict, :load) => [7.0 7.7; 8.1 8.1; 9.0 9.9]\n\njulia> [k => parent(parent(v)) for (k, v) in Impute.substitute(ds; dims=:loc).data]\n4-element Array{Pair{Tuple{Symbol,Symbol},Array{Union{Missing, Float64},2}},1}:\n   (:train, :temp) => [1.0 1.1; missing 2.2; 3.0 3.3]\n   (:train, :load) => [7.0 7.7; 8.0 8.8; 9.0 9.9]\n (:predict, :temp) => [1.0 missing; 2.0 2.2; 3.0 3.3]\n (:predict, :load) => [7.0 7.7; 8.1 8.8; 9.0 9.9]\n\n\n\n\n\n","category":"method"},{"location":"#Impute.validate-Tuple{KeyedDataset,Impute.Validator}","page":"Home","title":"Impute.validate","text":"Impute.validate(ds::KeyedDataset, validator::Validator; dims=:)\n\nApply the validator to components in the KeyedDataset with the specified dims.\n\n\n\n\n\n","category":"method"},{"location":"#NamedDims.dimnames-Tuple{KeyedDataset}","page":"Home","title":"NamedDims.dimnames","text":"dimnames(ds)\n\nReturns a list of the unique dimension names within the KeyedDataset.\n\nExample\n\njulia> using AxisKeys; using NamedDims; using AxisSets: KeyedDataset;\n\njulia> ds = KeyedDataset(\n           :val1 => KeyedArray(rand(4, 3, 2); time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n           :val2 => KeyedArray(rand(4, 3, 2) .+ 1.0; time=1:4, loc=-1:-1:-3, obj=[:a, :b]),\n       );\n\njulia> dimnames(ds)\n3-element Array{Symbol,1}:\n :time\n :loc\n :obj\n\n\n\n\n\n","category":"method"}]
}
